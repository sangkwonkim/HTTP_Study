// 상태코드
//     클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
//     1xx(Infomational)
//         요청이 수신되어 처리 중
//         > 거의 사용하지 않으므로 생략
        
//     2xx(Successful)
//         클라이언트의 요청을 성공적으로 처리
//         200 OK 요청 성공
//             > GET 
//         201(Created) 요청 성공해서 새로운 리소스 생성
//             > POST 
//             생성된 리소스는 응답의 Location 헤더 필드로 식별
//         202(Accepted) 요청이 접수되었으나 처리가 완료되지 않았음
//         204(No Content) 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없음
//             ex) 웹 문서 편집기에서 save 버튼
//             save 버튼 결과로 아무 내용이 없어도 된다
//             save 버튼 눌러도 같은 화면을 유지해야 한다
//             결과 내용이 없어도 204 메세지만으로 성공 인식 가능
        
//     2xx 다양한 상태코드가 있는데 다 사용하는 것이 좋냐?
//     > 200만 사용하는 곳, 200, 201만 사용하는 곳도 많다
//     개발 전에 팀이 정해서 사용하는 것이 좋다
    
//     //!> 파이널 프로젝트 SR단계에서 신경쓰지 못한 부분 다음에 서버 구현 시 SR 단계에서 db 스키마 구현하고 api 계획 시 반영할 필요가 있음


//     3xx(Redirection)
//         요청을 완료하기 위해 유저 에이전트의 추가 조치 필요
//         웹 브라우저는 3xx 응답의 결과에 location 헤더가 있으면 자동 이동한다(리다이렉트)

//         ex) 이전의 /event라는 페이지를 더 이상 이용하지 않는데
//         해당 페이지를 요청할 경우(GET), 서버에서 301 Moved Permanently로 응답하고
//         location 헤더가 있다면, 자동적으로 해당 주소로 이동하고 GET을 재요청한다

//         리다이렉션 종류

//         300 Multiple Choices 사용하지 않음

//             영구 리다이렉션 - 특정 리소스의 URI가 영구적으로 이동
//             > 앞선 예시와 같이 영구적으로 URI를 변경했는데 이전의 URI로 요청이 들어왔을 경우

//             원래의 URL를 사용하면 안됨. 검색 엔진 등에서도 변경 인지

//                 301 Moved Permanently
//                     > 리다이렉트 시 요청 메소드가 GET으로 변하고, 본문이 제거 될 수 있음
//                 308 Permanent Redirect
//                     > 301과 기능은 같지만,  리다이렉트시 요청 메소드와 본문이 유지가 됨
//                     페이지가 바뀌면 입력하는 것도 바뀌기 때문에 거의 사용하지 않음


//             일시 리다이렉션 - 일시적인 변경
//             > 주문 완료 후 주문 내역 화면으로 이동
//             일시 리다이렉션 예시
//                 PRG : Post/Redirect/Get
//                     POST 주문 후 웹 브라우저를 새로고침하면 POST가 다시 요청되고 중복 주문이 될 수 있다
//                     > 이 문제를 해결하기 위헤 PRG 사용
//                     POST 주문 후 새로 고침으로 인한 중복 주문 방지
//                     POST 주문 후 주문 결과 화면을 GET 메소드로 리다이렉트 > 새로고침 해도 GET으로 조회 > 중복 주문 대신 주문 결과 화면만 GET으로 재요청

//             리소스의 URI가 일시적으로 변경 따라서 검색 엔진 등에서 URL을 변경하면 안됨

//                 302 Found
//                     > 리다이렉트 시 요청 메소드가 GET으로 변하고, 본문이 제거될 수 있음(MAY)
//                     처음 302 스팩 의도는 HTTP 메소드를 유지하는 것이었으나, 웹 브라우저 대부분 GET으로 바꾸어버림(일부는 다르게 동작)
//                     > 이런 모호함때문에 303, 307이 등장함 > 303, 307을 권장하나 많은 애플리케이션 라이브러리에서 302를 기본값으로 사용
//                     자동 리다이렉션 시 GET으로 변해도 되면 그냥 302 써도 큰 문제는 없음

//                 307 Temporary Redirect
//                     > 302와 기능은 같음. 리다이렉트 시 요청 메소드와 본문 유지
//                 303 See Other
//                     > 302와 기능은 같음. 리다이렉트 시 요청 메소드가 GET으로 변경

//             특수 리다이렉션
//             > 결과 대신 캐시를 사용
//             캐시 기간 만료 여부를 클라이언트가 서버에 확인 요청 > 서버가 캐시가 만료되지 않았을 경우 캐시 사용 가능이라고 응답
                
//                 304 Not Modified > 캐시를 목적으로 사용
//                 클라이언트에게 리소스가 수정되지 않았음을 알렴 > 클라이언트는 로컬 PC에 저장된 캐시를 재사용(캐시로 리다이렉트) 네트워크 다운로드 용량이 줄어들 수 있음
//                 로컬 캐시를 사용해야 하므로 메세지 바디를 포함하면 안된다
//                 조건부 GET HEAD 요청 시 사용

//     4xx(Client Error)
//         클라이언트의 요청에 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
//         오류의 원인이 클라이언트에 있음
//         클라이언트가 이미 잘못된 요청, 데이터를 보내고 있기 때문에 똑같이 실패함
//         > 수정을 해서 보내야 한다

//         400(Bad Request)
//         클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음
//             요청 구문, 메세지 등등 오류이므로, 클라이언트는 요청 내용을 다시 검토하고 보내야함
//             ex) 요청 파라미터가 잘못되거나, api 스팩이 맞지 않을 때
//             > 철저한 validation이 필요함

//             //! 클라이언트의 요청에서 쿼리나 파람스 누락 시 400 에러 반영하기

//         401(Unauthorized)
//             클라이언트가 해당 리소스에 대한 인증이 필요함
//             인증(Authentication)이 되지 않음
//             401 오류 발생 시 응답에 WWW-Authenticate 헤더와 함께 인증 방법을 설명
            
//             인증(Authentication) : 본인이 누구인지 확인(로그인)
//             인가(Authorization) : 권한부여(admin 권한처럼 특정 리소스에 접근할 수 있는 권한, 인증이 있어야 인가가 있음)
//             오류 메세지가 비인가(Unauthorized)이지만 인증(Authentication)이 되지 않았을 때 에러임

//             //! 리팩토링 시 로그인하지 않은 유저(쿠키가 없는 경우)에 대한 요청 시 반영하기
//             //! 리프레쉬 토큰을 반영하지 않았기에 쿠키 만료에 따른 에러도 401로 처리 예정

//         403(Forbidden)
//             서버가 요청을 이해했지만 승인을 거부함
//             인증 자격 증명은 있지만, 접근 권한이 불충분한 경우
//             > admin 등급이 아닌 사용자(로그인 후) admin 등급 리소스에 접근할 때

//         404(Not Found) 
//             요청 리소스를 찾을 수 없음
//             > 요청 리소스가 서버에 없음 또는 클라이언트가 권한이 부족한 리소스에 접근할 때 해당 리소스를 숨기고 싶을 때

//     5xx(Server Error)
//         서버 오류
//         서버 문제로 오류 발생 > 서버에 문제가 있기 때문에 재시도하면 성공할 수도 있음(복구 등등)

//         500(Internal Server Error)
//             서버 문제로 오류 발생, 애매하면 500 오류
            
//             //! 클라이언트 에러 제외하고 처리 과정에서 발생하는 에러에 서버 에러 반영하기

//         503(Service Unavailable)
//             서비스 이용 불가
//             서버가 일시적인 과부화 또는 예정된 작업으로 잠시 요청을 처리할 수 없음
//             Retry-After 헤더 필드로 얼마뒤에 복구되는 지 보낼 수 있음
